require 'simrb/config'

module Simrb

	class Scommand

		def run args = []
			cmd = args.empty? ? '' : args.shift
			if Scommand.private_method_defined? cmd
				self.send(cmd, args)
			else
				Simrb.p "No #{cmd} command found"
			end
		end

		private

			# initialize a project directory
			#
			# == Example
			# 
			# 	$ simrb init myapp
			#
			# or, initialize directory and module, the simrb/system is from remote, 
			# the blog is generated by local
			#
			# 	$ simrb init myapp simrb/system blog
			#
			def init args
				app_name = args.empty? ? 'myapp' : args.shift 

				# generate module directories and files
				Dir.mkdir app_name
				Dir.chdir app_name

				Scfg[:init_root_path].each do | item |
					path = "#{Spath[item]}"
					Simrb::path_init path
				end

				# initialize scfg file
				data = {}
				Scfg[:init_scfg_item].each do | item |
					data[item] = Scfg[item]
				end
				Simrb.yaml_write('scfg', data)

				# create module if it is given,
				# get module from remote repository if it has the backslash,
				# other is created at local
				unless args.empty?
					args.each do | name |
						name.index("/") ? clone(args) : new(args)
					end
				end

				# initialize rubygem bundled
# 				mode = "develpment"
# 				if @args.include? '--dev'
# 					mode = "production"
# 				end
# 				system("bundle install --gemfile=#{@app_name}/apps/#{@module_name}#{@gemfile_path} --without=#{mode}")

				Simrb.p "Initialized project complete"
			end

			# create a module, initialize default paths of file and directory
			#
			# == Example
			# 
			# 	$ simrb new blog
			#
			def new args
				args.each do | module_name |
					# create root dir of module
					Simrb::path_init "#{Spath[:apps]}#{module_name}/"

					Dir.chdir "."

					# create sub dir of module 
					Scfg[:init_module_path].each do | item |
						path = "#{Spath[:apps]}#{module_name}#{Spath[item]}"
						Simrb::path_init path
					end

					# write the content of module info
					text = [{ 'name' => module_name }]
					Simrb.yaml_write "#{Spath[:apps]}#{module_name}#{Spath[:modinfo]}", text

					# write the content of .gitignore
					path = "#{Spath[:apps]}#{module_name}#{Spath[:gitignore]}"
					File.open(path, "w+") do | f |
						f.write "*.swp\n*.gem\n*~"
					end
				end

				Simrb.p "Initialized module complete"
			end

			# clone a module from remote repository to local
			#
			# == Example
			# 
			# 	$ simrb clone simrb/system
			#
			def clone args
				unless args.empty?
					system("git clone #{Scfg[:repo_source]}#{args[0]}.git #{Spath[:apps]}#{args[0].split('/').last}")
					Simrb.p "Cloned module complete"
				end
			end

			# kill the current process of Simrb of that is running in background
			#
			# == Example
			#
			# 	$ simrb kill
			#
			def kill
				s = `ps -ax | grep 'simrb start'`
				s = s.split("\n")[0].split(" ")[0]
# 				s = `cat #{Spath[:tmp_dir]}pid`.split("\n")[0]
# 				`rm #{Spath[:tmp_dir]}pid`

				system("kill #{s}")
				Simrb.p "Killed the process #{s} of Simrb"
			end

			# display the basic inforamtion of current version of Simrb
			#
			# == Example
			#
			# 	$ simrb info
			#
			def info
				require 'simrb/info'
				Simrb.p Simrb::Info
			end

	end

end

simrb_app = Simrb::Scommand.new
simrb_app.run ARGV
